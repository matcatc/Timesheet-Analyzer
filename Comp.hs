-- | This is the "Computation and Analysis" ("comp" for short) component of the Timesheet Analyzer program.
--
-- It is responsible for reading in the user's timesheet CSV file, crunching
-- some numbers, and generating a new CSV file. This new CSV file's format is
-- different from the input file in order to make processing by Gnuplot easier.
--
-- Author: Matthew Todd
-- Date: 2017-09-16

-- TODO: switch from String to ByteString or Text?
-- TODO: switch to a streaming based setup (instead of just lazy datatypes)?
--          Should only be necessary when processing really large inputs, so handle later.
-- TODO: switch out for a different CSV library later?

-- For cmdArgs
{-# LANGUAGE DeriveDataTypeable #-}

module Main where

import Control.Monad
    ( when
    )
import qualified Data.ByteString.Lazy as BS
import qualified Data.ByteString.Lazy.Char8 as C
import Data.Csv
import Data.Either
    (
    )
import Data.List
    ( intercalate
    )
import Data.Vector
    ( Vector
    )
import System.Directory
    ( doesFileExist
    )

-- TODO: separate out command line arguments stuff to a separate module?
import System.Console.CmdArgs

-- | Default output timesheet
_DEFAULT_OUTPUT_TIMESHEET :: String
_DEFAULT_OUTPUT_TIMESHEET = "intermediate_timesheet.csv"

-- | Header information for output timesheet
_OUTPUT_TIMESHEET_HEADER :: String
_OUTPUT_TIMESHEET_HEADER = "# Generated by Timesheet Analyzer"

-- Category names
_CATEGORY_LABOR :: String
_CATEGORY_LABOR = "labor"

_CATEGORY_SICK :: String
_CATEGORY_SICK = "sick"

_CATEGORY_VACATION :: String
_CATEGORY_VACATION = "vacation"

_CATEGORY_HOLIDAY :: String
_CATEGORY_HOLIDAY = "holiday"

_CATEGORY_COMP :: String
_CATEGORY_COMP = "comp"

-- | Comment character in timesheet CSV files
_COMMENT_CHARACTER :: Char
_COMMENT_CHARACTER = '#'

-- |
-- Numbers for a particular week
data WeekNumbers
    = WeekNumbers
        { monday :: Float
        , tuesday :: Float
        , wednesday :: Float
        , thursday :: Float
        , friday :: Float
        , saturday :: Float
        , sunday :: Float
        }
    -- TODO: derive other stuff?
    deriving (Show)

-- | empty WeekNumbers. Useful starting point.
emptyWeekNumbers :: WeekNumbers
emptyWeekNumbers = WeekNumbers
    { monday = 0
    , tuesday = 0
    , wednesday = 0
    , thursday = 0
    , friday = 0
    , saturday = 0
    , sunday = 0
    }

-- |
-- Our internal data type representation of the timesheet data for a week
-- TODO: rename?
data DataStruct
    = DataStruct
        { weekId :: String
        , laborHours :: WeekNumbers
        , sickHours :: WeekNumbers
        , vacationHours :: WeekNumbers
        , holidayHours :: WeekNumbers
        , compHours :: WeekNumbers
        }
    -- TODO: add total hours?
    -- TODO: derive other stuff?
    deriving (Show)

-- | Empty DataStruct. Useful for starting point
emptyDataStruct :: DataStruct
emptyDataStruct = DataStruct
    { weekId = ""
    , laborHours = emptyWeekNumbers
    , sickHours = emptyWeekNumbers
    , vacationHours = emptyWeekNumbers
    , holidayHours = emptyWeekNumbers
    , compHours = emptyWeekNumbers
    }

-- | Type representing a single line of CSV from an input file
type InputCsvLine =
    ( String -- ^ Week ID
    , String -- ^ category
    , Float  -- ^ Monday hours
    , Float  -- ^ Tuesday hours
    , Float  -- ^ Wednesday hours
    , Float  -- ^ Thursday hours
    , Float  -- ^ Friday hours
    , Float  -- ^ Saturday hours
    , Float  -- ^ Sunday hours
    )

-- | Type representing a single line of CSV for the output file
type OutputCsvLine =
    ( String -- ^ Week ID
    , Float  -- ^ Monday labor hours
    , Float  -- ^ Monday sick hours
    , Float  -- ^ Monday vacation hours
    , Float  -- ^ Monday holiday hours
    , Float  -- ^ Monday comp hours
    , Float  -- ^ Monday total hours
    , Float  -- ^ Tuesday labor hours
    , Float  -- ^ Tuesday sick hours
    , Float  -- ^ Tuesday vacation hours
    , Float  -- ^ Tuesday holiday hours
    , Float  -- ^ Tuesday comp hours
    , Float  -- ^ Tuesday total hours
    , Float  -- ^ Wednesday labor hours
    , Float  -- ^ Wednesday sick hours
    , Float  -- ^ Wednesday vacation hours
    , Float  -- ^ Wednesday holiday hours
    , Float  -- ^ Wednesday comp hours
    , Float  -- ^ Wednesday total hours
    , Float  -- ^ Thursday labor hours
    , Float  -- ^ Thursday sick hours
    , Float  -- ^ Thursday vacation hours
    , Float  -- ^ Thursday holiday hours
    , Float  -- ^ Thursday comp hours
    , Float  -- ^ Thursday total hours
    , Float  -- ^ Friday labor hours
    , Float  -- ^ Friday sick hours
    , Float  -- ^ Friday vacation hours
    , Float  -- ^ Friday holiday hours
    , Float  -- ^ Friday comp hours
    , Float  -- ^ Friday total hours
    , Float  -- ^ Saturday labor hours
    , Float  -- ^ Saturday sick hours
    , Float  -- ^ Saturday vacation hours
    , Float  -- ^ Saturday holiday hours
    , Float  -- ^ Saturday comp hours
    , Float  -- ^ Saturday total hours
    , Float  -- ^ Sunday labor hours
    , Float  -- ^ Sunday sick hours
    , Float  -- ^ Sunday vacation hours
    , Float  -- ^ Sunday holiday hours
    , Float  -- ^ Sunday comp hours
    , Float  -- ^ Sunday total hours
    , Float  -- ^ total labor hours
    , Float  -- ^ total sick hours
    , Float  -- ^ total vacation hours
    , Float  -- ^ total holiday hours
    , Float  -- ^ total comp hours
    , Float  -- ^ week total hours
    , Float  -- ^ comp earned this week
    , Float  -- ^ comp accrued/accumulated after this week
    )


data Options
    = Options
        { inputTimesheets :: [FilePath]
        , outputTimesheet :: FilePath
        }
    deriving (Data,Show,Typeable)

options :: Options
options = Options
    { inputTimesheets = def &= args &= typ "FILES"
    , outputTimesheet = _DEFAULT_OUTPUT_TIMESHEET &= typ "FILE"
    }

-- |
-- Check that the files exist
checkFilesExist :: [FilePath] -- ^ Files to veify exist
                -> IO Bool    -- ^ True if all files exist, False otherwise
checkFilesExist files = do
        xs <- mapM checkFile files
        return (and xs)
    where
        checkFile :: FilePath -> IO Bool
        checkFile file = do
                    fileExist <- doesFileExist file
                    if fileExist then
                        return True
                    else
                        putStrLn ("Error: file " ++ file ++ " does not exist.") >> return False

-- | 
-- Convert a single CSV line to our internal data type representation
convertInputCsvLine :: InputCsvLine -- ^ Our CSV line
               -> Either String DataStruct    -- ^ Either an error message or the converted data
convertInputCsvLine (week, category, mon, tue, wed, thu, fri, sat, sun) = 
        case category of
            -- TODO: can't use the constants here b/c case creates new variables during matching. Find another way that allows us to use the constants.
            "labor" -> Right $ weekDataStruct {laborHours = weekHours}
            "sick" -> Right $ weekDataStruct {sickHours = weekHours}
            "vacation" -> Right $ weekDataStruct {vacationHours = weekHours}
            "holiday" -> Right $ weekDataStruct {holidayHours = weekHours}
            "comp" -> Right $ weekDataStruct {compHours = weekHours}
            _ -> Left $ "Warning: unknown charge category '" ++ category ++ "'" 
    where
        weekDataStruct :: DataStruct
        weekDataStruct = emptyDataStruct {weekId = week}

        weekHours :: WeekNumbers
        weekHours = WeekNumbers mon tue wed thu fri sat sun

-- | Strip lines starting with comments
stripCommentLines :: BS.ByteString -> BS.ByteString
stripCommentLines xs = bsUnlines $ filter (not . startsWithComment) $ bsLines xs
    where
        bsLines :: BS.ByteString -> [BS.ByteString]
        bsLines = C.split '\n'

        bsUnlines :: [BS.ByteString] -> BS.ByteString
        bsUnlines = C.intercalate (C.singleton '\n')

        startsWithComment :: BS.ByteString -> Bool
        startsWithComment = BS.isPrefixOf (C.singleton _COMMENT_CHARACTER)

-- | Get cleaned input file contents
getCleanFileContents :: [FilePath] -> IO BS.ByteString
getCleanFileContents files = do
                fileContents <- mapM BS.readFile files
                return $ stripCommentLines $ BS.concat fileContents

-- |
-- Process the input files
-- TODO: use Either to return success status?
processFiles :: [FilePath]  -- ^ Input timesheets to process
             -> IO [String] -- ^ Return a list of lines to print to the output file
processFiles files = do
                fileContents <- getCleanFileContents files
                -- Convert text into CSV and check for any errors
                let eith = decode NoHeader fileContents :: Either String (Vector InputCsvLine) in
                    -- Check for any warnings
                    case eith of
                        Left errorStr -> putStrLn errorStr >> return ["processing failed"]
                        Right csvLines -> putStrLn "TODO: implement processFiles" >> return ["test1", "test2"]


-- |
-- Main function.
main :: IO ()
main = do
    opts <- cmdArgs options
    let inFiles = inputTimesheets opts
        outFile = outputTimesheet opts in 
        if null inFiles then
            putStrLn "Error: no input timesheets provided."
        else do
            filesExist <- checkFilesExist inFiles
            when filesExist $ do
                putStrLn $ "Will process the following timesheets: " ++ intercalate ", " inFiles
                outputMetrics <- processFiles inFiles
                putStrLn $ "Writing to output timesheet: " ++ outFile
                writeFile outFile $ unlines outputMetrics

